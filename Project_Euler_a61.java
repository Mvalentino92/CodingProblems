/*Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
 *
 * Triangle 	P3,n=n(n+1)/2 	1, 3, 6, 10, 15, ...
 * Square 	P4,n=n2 	1, 4, 9, 16, 25, ...
 * Pentagonal 	P5,n=n(3n−1)/25 	1, 5, 12, 22, 35, ...
 * Hexagonal 	P6,n=n(2n−1)2n 	1, 6, 15, 28, 45, ...
 * Heptagonal 	P7,n=n(5n−3)/28 	1, 7, 18, 34, 55, ...
 * Octagonal 	P8,n=n(3n−2)3n 	1, 8, 21, 40, 65, ...
 * The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
 *
 * The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
 * Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
 * This is the only set of 4-digit numbers with this property.
 * Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
 *
 */


import java.util.*;
public class Project_Euler_a61
{
	//Calculate polygonals.
	public static int getPolygonals(int n, int p)
	{
		if(p == 0) return (n*(n + 1))/2;
		else if(p == 1) return n*n;
		else if(p == 2) return (n*(3*n - 1))/2;
		else if(p == 3) return n*(2*n - 1);
		else if(p == 4) return (n*(5*n - 3))/2;
		else return n*(3*n - 2);
	}

	//Generate the polygonal lists
	public static ArrayList<int[]> getList()
	{
		ArrayList<int[]> lists = new ArrayList<>();
		for(int p = 0; p < 6; p++)
		{
			//Find how long each array needs to be.
			int number = 0;
			int n = 0;
			int count = 0;
			while(number < 10000)
			{
				if(number > 999) count++;
				number = getPolygonals(n++,p);
			}

			//Generate the actual lists.
			int[] nextPolygonals = new int[count];
			number = 0;
			n = 0;
			count = 0;
			while(number < 10000)
			{
				if(number > 999) nextPolygonals[count++] = number;
				number = getPolygonals(n++,p);
			}
			lists.add(nextPolygonals);
		}
		return lists;
	}

	//Check if the current list of numbers is clear.
	public static boolean isClear(int[] existingIndexes, int targetIndex)
	{
		for(int i = 0; i < existingIndexes.length; i++)
		{
			if(existingIndexes[i] == targetIndex) return false;
		}
		return true;
	}

	//Checks to see if the two numbers are cyclic.
	public static boolean isCyclic(int currentNumber, int targetNumber) {return currentNumber % 100 == targetNumber / 100 ? true : false;}

	//Backtracking algorithm to find the order of numbers.
	public static int getOrder(ArrayList<int[]> lists, int currentIndex, int[] existingIndexes, int[] polys, int currentNumber, int sum)
	{
		//Final check to see if the last and first numbers are cyclic.
		if(currentIndex == existingIndexes.length)
		{
			int firstNumber = polys[0];
			int lastNumber = polys[currentIndex - 1];
			return lastNumber % 100 == firstNumber / 100 ? sum : 0;
		}

		//Begin backtracking all the lists, only visiting ones that havent had a number from them used yet.
		for(int i = 0; i < lists.size(); i++)
		{
			if(isClear(existingIndexes,i))
			{
				int[] currentArray = lists.get(i);
				for(int j = 0; j < currentArray.length; j++)
				{
					int targetNumber = currentArray[j];
					if(isCyclic(currentNumber,targetNumber))
					{
						existingIndexes[currentIndex] = i;
						polys[currentIndex] = targetNumber;
						int retval = getOrder(lists,currentIndex + 1, existingIndexes, polys, targetNumber, sum + targetNumber);
						if(retval > 0) return retval;
					}
				}
				existingIndexes[currentIndex] = 0;
				polys[currentIndex] = 0;
			}
		}
		return 0;
	}

	//Main method.
	public static void main(String[] args)
	{
		//Generate all the variables needed for the first call of the backtracking method.
		ArrayList<int[]> lists = getList();
		int[] existingIndexes = new int[6];
		int[] polys = new int [6];

		int[] P3 = lists.get(0);
		for(int i = 0; i < P3.length; i++)
		{
			polys[0] = P3[i];
			int possibleSolution = getOrder(lists,1,existingIndexes,polys,polys[0],polys[0]);
			if(possibleSolution > 0)
			{
				System.out.print("The ordered set is: ");
				for(int j = 0; j < polys.length; j++) System.out.print(polys[j]+" ");
				System.out.println("\nThe sum of the set is "+possibleSolution+".");
			}
		}
	}
}
